%%
headers

#include "config.h"

#define NO_IMPORT_PYGOBJECT
#define NO_IMPORT_PYGTK
#include <pygobject.h>
#include <pygtk/pygtk.h>

#include "override_common.h"
#include "rb-util.h"
#include "rb-debug.h"

#include "rb-auto-playlist-source.h"
#include "rb-browser-source.h"
#include "rb-cut-and-paste-code.h"
#include "rb-dialog.h"
#include "rb-entry-view.h"
#include "rb-file-helpers.h"
#include "rb-library-browser.h"
#include "rb-metadata.h"
#include "rb-playlist-source.h"
#include "rb-player.h"
#include "rb-player-gst-filter.h"
#include "rb-player-gst-tee.h"
#include "rb-player-gst-data-tee.h"
#include "rb-plugin.h"
#include "rb-property-view.h"
#include "rb-rating.h"
#include "rb-removable-media-manager.h"
#include "rb-removable-media-source.h"
#include "rb-search-entry.h"
#include "rb-shell.h"
#include "rb-shell-player.h"
#include "rb-source.h"
#include "rb-source-search.h"
#include "rb-source-search-basic.h"
#include "rb-sourcelist.h"
#include "rb-sourcelist-model.h"
#include "rb-static-playlist-source.h"
#include "rb-streaming-source.h"
#include "rb-track-transfer-batch.h"
#include "rb-track-transfer-queue.h"
#include "rb-uri-dialog.h"

void pyrb_register_classes (PyObject *d);
void pyrb_add_constants (PyObject *module, const gchar *strip_prefix);

/* hacks to deal with the nonstandard class name RHYTHMDB */
#define RHYTHMDB_TYPE_RHYTHMDB RHYTHMDB_TYPE
#define RHYTHMDB_RHYTHMDB(o) RHYTHMDB(o)

%%
modulename rb
%%
import gobject.GObject as PyGObject_Type
import gtk.ActionGroup as PyGtkActionGroup_Type
import gtk.Dialog as PyGtkDialog_Type
import gtk.HBox as PyGtkHBox_Type
import gtk.ScrolledWindow as PyGtkScrolledWindow_Type
import gtk.TreeModel as PyGtkTreeModel_Type
import gtk.TreeModelFilter as PyGtkTreeModelFilter_Type
import gtk.TreeView as PyGtkTreeView_Type
import gtk.TreeViewColumn as PyGtkTreeViewColumn_Type
import gtk.UIManager as PyGtkUIManager_Type
import gtk.VBox as PyGtkVBox_Type
import gtk.Widget as PyGtkWidget_Type
import gtk.Window as PyGtkWindow_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type

import gst.Element as PyGstElement_Type

import rhythmdb.StringValueMap as PyRBStringValueMap_Type
import rhythmdb.Entry as PyRhythmDBEntry_Type
import rhythmdb.EntryType as PyRhythmDBEntryType_Type
import rhythmdb.PropertyModel as PyRhythmDBPropertyModel_Type
import rhythmdb.PropertyModelColumn as PyRhythmDBPropertyModelColumn_Type
import rhythmdb.PropType as PyRhythmDBPropType_Type
import rhythmdb.Query as PyRhythmDBQuery_Type
import rhythmdb.QueryModel as PyRhythmDBQueryModel_Type
import rhythmdb.QueryResults as PyRhythmDBQueryResults_Type
import rhythmdb.QueryModelLimitType as PyRhythmDBQueryModelLimitType_Type
import rhythmdb.QueryType as PyRhythmDBQueryType_Type
import rhythmdb.RhythmDB as PyRhythmDB_Type
%%
new-constructor RB_TYPE_BROWSER_SOURCE
new-constructor RB_TYPE_SOURCE
%%
ignore-glob
  *_get_type
  *_quark
%%
override rb_entry_view_append_column_custom kwargs
static PyObject *
_wrap_rb_entry_view_append_column_custom(PyGObject *self, PyObject *args,
                                         PyObject *kwargs)
{
    static char *kwlist[] = { "column", "title", "key", "sort_func", "sort_data", NULL };
    PyGObject *pycolumn = NULL;
    PyObject *pyfunc = NULL;
    PyObject *pyarg = NULL;
    char *title, *key;
  
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Ozz|OO:RBEntryView.append_column_custom",
                                     kwlist, &pycolumn, &title, &key, &pyfunc, &pyarg))
        return NULL;

    if (pyfunc != Py_None && pyfunc != NULL) {
        PyRhythmDBQueryModelSortData *data;

        if (!PyCallable_Check(pyfunc)) {
            PyErr_SetString(PyExc_TypeError,
                            "sort_func must be a callable object");
            return NULL;
        }
        data = g_new0(PyRhythmDBQueryModelSortData, 1);
        data->func = pyfunc;
        data->data = pyarg;
        Py_INCREF(data->func);
        Py_XINCREF(data->data);

        rb_entry_view_append_column_custom(RB_ENTRY_VIEW(self->obj),
                                           GTK_TREE_VIEW_COLUMN(pycolumn->obj),
                                           title, key,
                                           (GCompareDataFunc) _rhythmdb_query_model_sort_func,
                                           data,
                                           (GDestroyNotify) _rhythmdb_query_model_sort_data_free);
    } else {
        rb_entry_view_append_column_custom(RB_ENTRY_VIEW(self->obj),
                                           GTK_TREE_VIEW_COLUMN(pycolumn->obj),
                                           title, key, NULL, NULL, NULL);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override rb_entry_view_insert_column_custom kwargs
static PyObject *
_wrap_rb_entry_view_insert_column_custom(PyGObject *self, PyObject *args,
                                         PyObject *kwargs)
{
    static char *kwlist[] = { "column", "title", "key", "position", "sort_func", "sort_data", NULL };
    PyGObject *pycolumn;
    PyObject *pyfunc = NULL;
    PyObject *pyarg = NULL;
    char *title, *key;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Ozzi|OO:RBEntryView.insert_column_custom",
                                     kwlist, &pycolumn, &title, &key, &position, &pyfunc, &pyarg))
        return NULL;

    if (pyfunc != Py_None && pyfunc != NULL) {
        PyRhythmDBQueryModelSortData *data;
        if (!PyCallable_Check(pyfunc)) {
            PyErr_SetString(PyExc_TypeError,
                            "sort_func must be a callable object");
            return NULL;
        }
        data = g_new0(PyRhythmDBQueryModelSortData, 1);
        data->func = pyfunc;
        data->data = pyarg;
        Py_INCREF(data->func);
        Py_XINCREF(data->data);

        rb_entry_view_insert_column_custom(RB_ENTRY_VIEW(self->obj),
                                           GTK_TREE_VIEW_COLUMN(pycolumn->obj),
                                           title, key,
                                           (GCompareDataFunc) _rhythmdb_query_model_sort_func,
                                           data, (GDestroyNotify) _rhythmdb_query_model_sort_data_free,
                                           position);
    } else {
        rb_entry_view_insert_column_custom(RB_ENTRY_VIEW(self->obj),
                                           GTK_TREE_VIEW_COLUMN(pycolumn->obj),
                                           title, key,
                                           NULL, NULL, NULL,
                                           position);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override rb_entry_view_get_selected_entries noargs
static PyObject *
_wrap_rb_entry_view_get_selected_entries(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_entry_view_get_selected_entries (RB_ENTRY_VIEW(self->obj));
    py_list = _helper_wrap_boxed_glist (list, RHYTHMDB_TYPE_ENTRY, FALSE, TRUE);
    g_list_free (list);

    return py_list;
}
%%
override rb_source_get_property_views noargs
static PyObject *
_wrap_rb_source_get_property_views(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_source_get_property_views (RB_SOURCE(self->obj));
    py_list = _helper_wrap_gobject_glist (list);
    g_list_free (list);

    return py_list;
}
%%
override rb_source_get_search_actions noargs
static PyObject *
_wrap_rb_source_get_search_actions(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_source_get_search_actions (RB_SOURCE(self->obj));
    py_list = _helper_wrap_string_glist (list);
    rb_list_deep_free (list);

    return py_list;
}
%%
override rb_source_get_ui_actions noargs
static PyObject *
_wrap_rb_source_get_ui_actions(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_source_get_ui_actions (RB_SOURCE(self->obj));
    py_list = _helper_wrap_string_glist (list);
    rb_list_deep_free (list);

    return py_list;
}
%%
override rb_source_cut noargs
static PyObject *
_wrap_rb_source_cut(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_source_cut (RB_SOURCE(self->obj));
    py_list = _helper_wrap_boxed_glist (list, RHYTHMDB_TYPE_ENTRY, TRUE, TRUE);
    g_list_free (list);

    return py_list;
}
%%
override rb_source_copy noargs
static PyObject *
_wrap_rb_source_copy(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_source_copy (RB_SOURCE(self->obj));
    py_list = _helper_wrap_boxed_glist (list, RHYTHMDB_TYPE_ENTRY, TRUE, TRUE);
    g_list_free (list);

    return py_list;
}
%%
override rb_source_paste kwargs
static PyObject *
_wrap_rb_source_paste(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "entries", NULL };
    PyObject *py_entries = NULL;
    GList *entries;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:RBSource.copy", kwlist, &py_entries))
        return NULL;

    entries = _helper_unwrap_boxed_pylist (py_entries, RHYTHMDB_TYPE_ENTRY);
    rb_source_paste (RB_SOURCE(self->obj), entries);
    g_list_free (entries);

    Py_RETURN_NONE;
}
%%
override rb_source_gather_selected_properties kwargs
static PyObject *
_wrap_rb_source_gather_selected_properties(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "keys", NULL };
	PyObject *py_propid, *py_list;
	int propid;
	GList *list;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:RBSource.gather_selected_properties", kwlist, &py_propid))
		return NULL;
	if (pyg_enum_get_value(RHYTHMDB_TYPE_PROP_TYPE, py_propid, &propid))
		return NULL;

	list = rb_source_gather_selected_properties (RB_SOURCE(self->obj), (RhythmDBPropType)propid);
	py_list = _helper_wrap_string_glist (list);
	rb_list_deep_free (list);

	return py_list;
}
%%
override rb_property_view_set_selection kwargs
static PyObject *
_wrap_rb_property_view_set_selection(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "strings", NULL };
    PyObject *py_strings = NULL;
    GList *strings;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:RBPropertyView.set_selection", kwlist, &py_strings))
        return NULL;

    strings = _helper_unwrap_string_pylist (py_strings, FALSE);
    rb_property_view_set_selection (RB_PROPERTY_VIEW(self->obj), strings);
    g_list_free (strings);

    Py_RETURN_NONE;
}
%%
override rb_property_view_get_selection noargs
static PyObject *
_wrap_rb_property_view_get_selection(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_property_view_get_selection (RB_PROPERTY_VIEW(self->obj));
    py_list = _helper_wrap_string_glist (list);
    rb_list_deep_free (list);

    return py_list;
}
%%
override rb_shell_player_get_volume noargs
static PyObject *
_wrap_rb_shell_player_get_volume(PyGObject *self)
{
    gdouble vol = 0.0;
    GError *error = NULL;

    rb_shell_player_get_volume(RB_SHELL_PLAYER(self->obj), &vol, &error);

    if (pyg_error_check(&error))
        return NULL;

    return PyFloat_FromDouble(vol);
}
%%
override rb_shell_player_get_mute noargs
static PyObject *
_wrap_rb_shell_player_get_mute(PyGObject *self)
{
    gboolean muted = FALSE;
    GError *error = NULL;

    rb_shell_player_get_mute(RB_SHELL_PLAYER(self->obj), &muted, &error);

    if (pyg_error_check(&error))
        return NULL;

    return PyBool_FromLong((long) muted);
}
%%
override rb_shell_player_get_playing noargs
static PyObject *
_wrap_rb_shell_player_get_playing(PyGObject *self)
{
    gboolean playing = FALSE;
    GError *error = NULL;

    rb_shell_player_get_playing(RB_SHELL_PLAYER(self->obj), &playing, &error);

    if (pyg_error_check(&error))
        return NULL;

    return PyBool_FromLong((long) playing);
}
%%
override rb_shell_player_get_playing_time noargs
static PyObject *
_wrap_rb_shell_player_get_playing_time(PyGObject *self)
{
    guint time = 0;
    GError *error = NULL;

    rb_shell_player_get_playing_time(RB_SHELL_PLAYER(self->obj), &time, &error);

    if (pyg_error_check(&error))
        return NULL;

    return PyLong_FromLong((long) time);
}
%%
override rb_shell_player_get_playing_path noargs
static PyObject *
_wrap_rb_shell_player_get_playing_path(PyGObject *self)
{
    const char *path = NULL;
    GError *error = NULL;

    rb_shell_player_get_playing_path(RB_SHELL_PLAYER(self->obj), &path, &error);

    if (pyg_error_check(&error))
        return NULL;

    if (path == NULL) {
        Py_RETURN_NONE;
    } else {
        return PyString_FromString (path);
    }
}
%%
override RBSource__do_impl_cut
static PyObject *
_wrap_RBSource__do_impl_cut(PyObject *cls, PyObject *args, PyObject *kwargs)
{
	gpointer klass;
	static char *kwlist[] = { "self", NULL };
	PyGObject *self;
	GList *ret;
	PyObject *py_ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBSource.impl_cut", kwlist, &PyRBSource_Type, &self))
		return NULL;
	klass = g_type_class_ref(pyg_type_from_object(cls));
	if (RB_SOURCE_CLASS(klass)->impl_cut)
		ret = RB_SOURCE_CLASS(klass)->impl_cut(RB_SOURCE(self->obj));
	else {
		PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_cut not implemented");
		g_type_class_unref(klass);
		return NULL;
	}
	g_type_class_unref(klass);
	py_ret = _helper_wrap_boxed_glist (ret, RHYTHMDB_TYPE_ENTRY, TRUE, TRUE);
	g_list_free (ret);
	return py_ret;
}
%%
override RBSource__proxy_do_impl_cut
static GList *
_wrap_RBSource__proxy_do_impl_cut (RBSource *self)
{
	PyGILState_STATE __py_state;
	PyObject *py_self;
	PyObject *py_method;
	PyObject *py_retval;
	GList *ret = NULL;

	__py_state = pyg_gil_state_ensure();
	py_self = pygobject_new((GObject *)self);
	if (!py_self) {
		if (PyErr_Occurred())
			PyErr_Print();
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_method = PyObject_GetAttrString(py_self, "do_impl_cut");
	if (!py_method) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_retval = PyObject_CallObject(py_method, NULL);
	if (!py_retval) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_method);
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	ret = _helper_unwrap_boxed_pylist (py_retval, RHYTHMDB_TYPE_ENTRY);

	Py_DECREF(py_retval);
	Py_DECREF(py_method);
	Py_DECREF(py_self);
	pyg_gil_state_release(__py_state);

	return ret;
}
%%
override RBSource__do_impl_copy
static PyObject *
_wrap_RBSource__do_impl_copy(PyObject *cls, PyObject *args, PyObject *kwargs)
{
	gpointer klass;
	static char *kwlist[] = { "self", NULL };
	PyGObject *self;
	GList *ret;
	PyObject *py_ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBSource.impl_copy", kwlist, &PyRBSource_Type, &self))
		return NULL;
	klass = g_type_class_ref(pyg_type_from_object(cls));
	if (RB_SOURCE_CLASS(klass)->impl_copy)
		ret = RB_SOURCE_CLASS(klass)->impl_copy(RB_SOURCE(self->obj));
	else {
		PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_copy not implemented");
		g_type_class_unref(klass);
		return NULL;
	}
	g_type_class_unref(klass);
	py_ret = _helper_wrap_boxed_glist (ret, RHYTHMDB_TYPE_ENTRY, TRUE, TRUE);
	g_list_free (ret);
	return py_ret;
}
%%
override RBSource__proxy_do_impl_copy
static GList *
_wrap_RBSource__proxy_do_impl_copy (RBSource *self)
{
	PyGILState_STATE __py_state;
	PyObject *py_self;
	PyObject *py_method;
	PyObject *py_retval;
	GList *ret = NULL;

	__py_state = pyg_gil_state_ensure();
	py_self = pygobject_new((GObject *)self);
	if (!py_self) {
		if (PyErr_Occurred())
			PyErr_Print();
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_method = PyObject_GetAttrString(py_self, "do_impl_copy");
	if (!py_method) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_retval = PyObject_CallObject(py_method, NULL);
	if (!py_retval) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_method);
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	ret = _helper_unwrap_boxed_pylist (py_retval, RHYTHMDB_TYPE_ENTRY);

	Py_DECREF(py_retval);
	Py_DECREF(py_method);
	Py_DECREF(py_self);
	pyg_gil_state_release(__py_state);

	return ret;
}
%%
override RBSource__do_impl_get_property_views
static PyObject *
_wrap_RBSource__do_impl_get_property_views(PyObject *cls, PyObject *args, PyObject *kwargs)
{
	gpointer klass;
	static char *kwlist[] = { "self", NULL };
	PyGObject *self;
	GList *ret;
	PyObject *py_ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBSource.impl_get_property_views", kwlist, &PyRBSource_Type, &self))
		return NULL;
	klass = g_type_class_ref(pyg_type_from_object(cls));
	if (RB_SOURCE_CLASS(klass)->impl_get_property_views)
		ret = RB_SOURCE_CLASS(klass)->impl_get_property_views(RB_SOURCE(self->obj));
	else {
		PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_get_property_views not implemented");
		g_type_class_unref(klass);
		return NULL;
	}
	g_type_class_unref(klass);
	py_ret = _helper_wrap_gobject_glist (ret);
	g_list_free (ret);
	return py_ret;
}
%%
override RBSource__proxy_do_impl_get_property_views
static GList *
_wrap_RBSource__proxy_do_impl_get_property_views (RBSource *self)
{
	PyGILState_STATE __py_state;
	PyObject *py_self;
	PyObject *py_method;
	PyObject *py_retval;
	GList *ret = NULL;

	__py_state = pyg_gil_state_ensure();
	py_self = pygobject_new((GObject *)self);
	if (!py_self) {
		if (PyErr_Occurred())
			PyErr_Print();
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_method = PyObject_GetAttrString(py_self, "do_impl_get_property_views");
	if (!py_method) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_retval = PyObject_CallObject(py_method, NULL);
	if (!py_retval) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_method);
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	ret = _helper_unwrap_gobject_pylist (py_retval);

	Py_DECREF(py_retval);
	Py_DECREF(py_method);
	Py_DECREF(py_self);
	pyg_gil_state_release(__py_state);

	return ret;
}
%%
override RBSource__do_impl_get_ui_actions
static PyObject *
_wrap_RBSource__do_impl_get_ui_actions(PyObject *cls, PyObject *args, PyObject *kwargs)
{
	gpointer klass;
	static char *kwlist[] = { "self", NULL };
	PyGObject *self;
	GList *ret;
	PyObject *py_ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBSource.impl_get_ui_actions", kwlist, &PyRBSource_Type, &self))
		return NULL;
	klass = g_type_class_ref(pyg_type_from_object(cls));
	if (RB_SOURCE_CLASS(klass)->impl_get_ui_actions)
		ret = RB_SOURCE_CLASS(klass)->impl_get_ui_actions(RB_SOURCE(self->obj));
	else {
		PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_get_ui_actions not implemented");
		g_type_class_unref(klass);
		return NULL;
	}
	g_type_class_unref(klass);
	py_ret = _helper_wrap_string_glist (ret);
	rb_list_deep_free (ret);
	return py_ret;
}
%%
override RBSource__proxy_do_impl_get_ui_actions
static GList *
_wrap_RBSource__proxy_do_impl_get_ui_actions (RBSource *self)
{
	PyGILState_STATE __py_state;
	PyObject *py_self;
	PyObject *py_method;
	PyObject *py_retval;
	GList *ret;

	__py_state = pyg_gil_state_ensure();
	py_self = pygobject_new((GObject *)self);
	if (!py_self) {
		if (PyErr_Occurred())
			PyErr_Print();
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_method = PyObject_GetAttrString(py_self, "do_impl_get_ui_actions");
	if (!py_method) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_retval = PyObject_CallObject(py_method, NULL);
	if (!py_retval) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_method);
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	ret = _helper_unwrap_string_pylist (py_retval, TRUE);

	Py_DECREF(py_retval);
	Py_DECREF(py_method);
	Py_DECREF(py_self);
	pyg_gil_state_release(__py_state);

	return ret;
}
%%
override RBSource__do_impl_get_search_actions
static PyObject *
_wrap_RBSource__do_impl_get_search_actions(PyObject *cls, PyObject *args, PyObject *kwargs)
{
	gpointer klass;
	static char *kwlist[] = { "self", NULL };
	PyGObject *self;
	GList *ret;
	PyObject *py_ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBSource.impl_get_search_actions", kwlist, &PyRBSource_Type, &self))
		return NULL;
	klass = g_type_class_ref(pyg_type_from_object(cls));
	if (RB_SOURCE_CLASS(klass)->impl_get_search_actions)
		ret = RB_SOURCE_CLASS(klass)->impl_get_search_actions(RB_SOURCE(self->obj));
	else {
		PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_get_search_actions not implemented");
		g_type_class_unref(klass);
		return NULL;
	}
	g_type_class_unref(klass);
	py_ret = _helper_wrap_string_glist (ret);
	rb_list_deep_free (ret);
	return py_ret;
}
%%
override RBSource__proxy_do_impl_get_search_actions
static GList *
_wrap_RBSource__proxy_do_impl_get_search_actions (RBSource *self)
{
	PyGILState_STATE __py_state;
	PyObject *py_self;
	PyObject *py_method;
	PyObject *py_retval;
	GList *ret;

	__py_state = pyg_gil_state_ensure();
	py_self = pygobject_new((GObject *)self);
	if (!py_self) {
		if (PyErr_Occurred())
			PyErr_Print();
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_method = PyObject_GetAttrString(py_self, "do_impl_get_search_actions");
	if (!py_method) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_retval = PyObject_CallObject(py_method, NULL);
	if (!py_retval) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_method);
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	ret = _helper_unwrap_string_pylist (py_retval, TRUE);

	Py_DECREF(py_retval);
	Py_DECREF(py_method);
	Py_DECREF(py_self);
	pyg_gil_state_release(__py_state);

	return ret;
}
%%
override rb_shell_player_get_playback_state noargs
static PyObject *
_wrap_rb_shell_player_get_playback_state(PyGObject *self)
{
    gboolean shuffle = FALSE;
    gboolean repeat = FALSE;

    if (!rb_shell_player_get_playback_state(RB_SHELL_PLAYER(self->obj), &shuffle, &repeat))
        return NULL;

    return Py_BuildValue ("bb", shuffle, repeat);
}
%%
override rb_entry_view_get_sorting_order noargs
static PyObject *
_wrap_rb_entry_view_get_sorting_order(PyGObject *self)
{
    char *column = NULL;
    gint order = 0;
    PyObject *object;

    rb_entry_view_get_sorting_order(RB_ENTRY_VIEW(self->obj), &column, &order);
    object = Py_BuildValue ("si", column, order);
    g_free (column);

    return object;
}
%%
override rb_entry_view_set_fixed_column_width kwargs
static PyObject *
_wrap_rb_entry_view_set_fixed_column_width(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "column", "renderer", "strings", NULL };
	PyGObject *py_column = NULL;
	PyGObject *py_renderer = NULL;
	PyObject *py_strings = NULL;
	const char **strings;
	int length, i;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:RBEntryView.set_fixed_column_width", kwlist,
	    &py_column, &py_renderer, &py_strings))
		return NULL;

	/* build the string list */
	length = PySequence_Length (py_strings);
	if (length < 0)
		return NULL;
	strings = g_new0(const char*, length+1);
	for (i = 0; i < length; i++) {
		PyObject *o;

		o = PySequence_GetItem (py_strings, i);
		strings[i] = PyString_AsString (o);
		Py_DECREF (o);
	}

	rb_entry_view_set_fixed_column_width (RB_ENTRY_VIEW (self->obj),
					      GTK_TREE_VIEW_COLUMN (py_column->obj),
					      GTK_CELL_RENDERER (py_renderer->obj),
					      strings);
	g_free (strings);

	Py_RETURN_NONE;
}
%%
override RBSource__do_impl_paste
static PyObject *
_wrap_RBSource__do_impl_paste(PyObject *cls, PyObject *args, PyObject *kwargs)
{
	gpointer klass;
	static char *kwlist[] = { "self", "entries",NULL };
	PyGObject *self;
	PyObject *py_entries;
	GList *entries;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!O:RBSource.impl_paste", kwlist, &PyRBSource_Type, &self, &py_entries))
		return NULL;

	entries = _helper_unwrap_boxed_pylist (py_entries, RHYTHMDB_TYPE_ENTRY);

	klass = g_type_class_ref(pyg_type_from_object(cls));
	if (RB_SOURCE_CLASS(klass)->impl_paste)
		RB_SOURCE_CLASS(klass)->impl_paste(RB_SOURCE(self->obj), entries);
	else {
		PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_paste not implemented");
		g_type_class_unref(klass);
		return NULL;
	}
	g_type_class_unref(klass);
	g_list_free (entries);

	Py_RETURN_NONE;
}
%%
override RBSource__proxy_do_impl_paste
static void
_wrap_RBSource__proxy_do_impl_paste(RBSource *self, GList *entries)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_entries;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;

    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    py_entries = _helper_wrap_boxed_glist (entries, RHYTHMDB_TYPE_ENTRY, FALSE, FALSE);

    py_args = PyTuple_New(1);
    Py_INCREF(py_entries);
    PyTuple_SET_ITEM(py_args, 0, py_entries);

    py_method = PyObject_GetAttrString(py_self, "do_impl_paste");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        if (PyErr_Occurred())
            PyErr_Print();
        PyErr_SetString(PyExc_TypeError, "retval should be None");
        Py_DECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }

    Py_DECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

%%
override rb_library_browser_get_property_views noargs
static PyObject *
_wrap_rb_library_browser_get_property_views(PyGObject *self)
{
	PyObject *py_list;
	GList *list;

	list = rb_library_browser_get_property_views (RB_LIBRARY_BROWSER(self->obj));
	py_list = _helper_wrap_gobject_glist (list);
	g_list_free (list);

	return py_list;
}

%%
override rb_library_browser_set_selection kwargs
static PyObject *
_wrap_rb_library_browser_set_selection(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", "keys", NULL };
    PyObject *py_keys = NULL;
    PyObject *py_propid = NULL;
    int propid;
    GList *keys;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:RBLibraryBrowser.set_selection", kwlist, &py_propid, &py_keys))
        return NULL;
    if (pyg_enum_get_value(RHYTHMDB_TYPE_PROP_TYPE, py_propid, &propid))
        return NULL;

    keys = _helper_unwrap_string_pylist (py_keys, FALSE);
    rb_library_browser_set_selection (RB_LIBRARY_BROWSER(self->obj), (RhythmDBPropType)propid, keys);
    g_list_free (keys);

	Py_RETURN_NONE;
}

%%
override rb_source_get_status noargs
static PyObject *
_wrap_rb_source_get_status(PyGObject *self)
{
    char *status_text = NULL;
    char *progress_text = NULL;
    float progress = 0.0f;
    PyObject *tuple;

    rb_source_get_status (RB_SOURCE (self->obj), &status_text, &progress_text, &progress);
    tuple = Py_BuildValue ("ssf", status_text, progress_text, progress);
    g_free (status_text);
    g_free (progress_text);
    return tuple;
}

%%
override RBSource__proxy_do_impl_get_status
static void
_wrap_RBSource__proxy_do_impl_get_status(RBSource *self, char **status_text, char **progress_text, float *progress)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    const char *st, *pt;

    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }

    py_method = PyObject_GetAttrString(py_self, "do_impl_get_status");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval == Py_None) {
        if (PyErr_Occurred())
            PyErr_Print();
        PyErr_SetString(PyExc_TypeError, "retval was None");
        Py_DECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }

    PyArg_ParseTuple (py_retval, "zzf", &st, &pt, progress);
    if (st)
      *status_text = g_strdup (st);
    else
      *status_text = NULL;
    if (pt)
      *progress_text = g_strdup (pt);
    else
      *progress_text = NULL;

    Py_DECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}

%%
override RBSource__do_impl_get_status
static PyObject *
_wrap_RBSource__do_impl_get_status(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    PyObject *tuple;
    char *status_text = NULL;
    char *progress_text = NULL;
    float progress = 0.0f;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBSource.impl_get_status", kwlist, &PyRBSource_Type, &self))
	return NULL;

    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (RB_SOURCE_CLASS(klass)->impl_get_status) {
	RB_SOURCE_CLASS(klass)->impl_get_status(RB_SOURCE(self->obj), &status_text, &progress_text, &progress);
    } else {
	PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_get_status not implemented");
	g_type_class_unref(klass);
	return NULL;
    }
    g_type_class_unref(klass);

    tuple = Py_BuildValue ("(ssf)", status_text, progress_text, progress);
    g_free (status_text);
    g_free (progress_text);
    return tuple;
}
%%
override rb_debug_real kwargs

static PyObject *
_wrap_rb_debug_real(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "function", "file", "line", "newline", "str", NULL };
    char *function, *file, *str;
    int line, newline;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ssiis:debug_real", kwlist, &function, &file, &line, &newline, &str))
        return NULL;
    rb_debug_real(function, file, line, (newline != 0), "%s", str);
	Py_RETURN_NONE;
}
%%
override RBSource__proxy_do_impl_get_browser_key
static char *
_wrap_RBSource__proxy_do_impl_get_browser_key(RBSource *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    char *ret = NULL;

    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }

    py_method = PyObject_GetAttrString(py_self, "do_impl_get_browser_key");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (py_retval == Py_None) {
        if (PyErr_Occurred())
            PyErr_Print();
        PyErr_SetString(PyExc_TypeError, "retval was None");
    } else if (PyString_Check(py_retval) == FALSE) {
        /* nothing */
    } else {
    	ret = g_strdup (PyString_AsString(py_retval));
    }

    Py_DECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);

    return ret;
}

%%
override RBSource__do_impl_get_browser_key
static PyObject *
_wrap_RBSource__do_impl_get_browser_key(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    PyObject *tuple;
    char *key = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBSource.impl_get_browser_key", kwlist, &PyRBSource_Type, &self))
	return NULL;

    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (RB_SOURCE_CLASS(klass)->impl_get_browser_key) {
	key = RB_SOURCE_CLASS(klass)->impl_get_browser_key(RB_SOURCE(self->obj));
    } else {
	PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_get_browser_key not implemented");
	g_type_class_unref(klass);
	return NULL;
    }
    g_type_class_unref(klass);

    tuple = Py_BuildValue ("(s)", key);
    g_free (key);
    return tuple;
}
%%
override RBBrowserSource__proxy_do_impl_get_paned_key
static char *
_wrap_RBBrowserSource__proxy_do_impl_get_paned_key(RBBrowserSource *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    char *ret = NULL;

    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }

    py_method = PyObject_GetAttrString(py_self, "do_impl_get_paned_key");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (py_retval == Py_None) {
        if (PyErr_Occurred())
            PyErr_Print();
        PyErr_SetString(PyExc_TypeError, "retval was None");
    } else if (PyString_Check(py_retval) == FALSE) {
        /* nothing */
    } else {
    	ret = g_strdup (PyString_AsString(py_retval));
    }

    Py_DECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);

    return ret;
}

%%
override RBBrowserSource__do_impl_get_paned_key
static PyObject *
_wrap_RBBrowserSource__do_impl_get_paned_key(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    PyObject *tuple;
    char *key = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBBrowserSource.impl_get_paned_key", kwlist, &PyRBBrowserSource_Type, &self))
	return NULL;

    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (RB_BROWSER_SOURCE_CLASS(klass)->impl_get_paned_key) {
	key = RB_BROWSER_SOURCE_CLASS(klass)->impl_get_paned_key(RB_BROWSER_SOURCE(self->obj));
    } else {
	PyErr_SetString(PyExc_NotImplementedError, "virtual method RBBrowserSource.impl_get_paned_key not implemented");
	g_type_class_unref(klass);
	return NULL;
    }
    g_type_class_unref(klass);

    tuple = Py_BuildValue ("(s)", key);
    g_free (key);
    return tuple;
}
%%
override rb_removable_media_source_get_mime_types noargs
static PyObject *
_wrap_rb_removable_media_source_get_mime_types(PyGObject *self)
{
    GList *list;
    PyObject *py_list;

    list = rb_removable_media_source_get_mime_types (RB_REMOVABLE_MEDIA_SOURCE (self->obj));
    py_list = _helper_wrap_string_glist (list);
    rb_list_deep_free (list);

    return py_list;
}
%%
override rb_static_playlist_source_add_locations kwargs
static PyObject *
_wrap_rb_static_playlist_source_add_locations (PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "locations", NULL };
    PyObject *py_locations = NULL;
    GList *locations;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:RBStaticPlaylistSoruce.add_locations", kwlist, &py_locations))
        return NULL;

    locations = _helper_unwrap_string_pylist (py_locations, FALSE);
    rb_static_playlist_source_add_locations (RB_STATIC_PLAYLIST_SOURCE (self->obj), locations);
    g_list_free (locations);

    Py_RETURN_NONE;
}
%%
override RBRemovableMediaSource__do_impl_get_mime_types
static PyObject *
_wrap_RBRemovableMediaSource__do_impl_get_mime_types(PyObject *cls, PyObject *args, PyObject *kwargs)
{
	gpointer klass;
	static char *kwlist[] = { "self", NULL };
	PyGObject *self;
	GList *ret;
	PyObject *py_ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBRemovableMediaSource.impl_get_mime_types", kwlist, &PyRBSource_Type, &self))
		return NULL;
	klass = g_type_class_ref(pyg_type_from_object(cls));
	if (RB_REMOVABLE_MEDIA_SOURCE_CLASS(klass)->impl_get_mime_types)
		ret = RB_REMOVABLE_MEDIA_SOURCE_CLASS(klass)->impl_get_mime_types(RB_REMOVABLE_MEDIA_SOURCE(self->obj));
	else {
		PyErr_SetString(PyExc_NotImplementedError, "virtual method RBRemovableMediaSource.impl_get_mime_types not implemented");
		g_type_class_unref(klass);
		return NULL;
	}
	g_type_class_unref(klass);
	py_ret = _helper_wrap_string_glist (ret);
	rb_list_deep_free (ret);
	return py_ret;
}
%%
override RBRemovableMediaSource__proxy_do_impl_get_mime_types
static GList *
_wrap_RBRemovableMediaSource__proxy_do_impl_get_mime_types (RBRemovableMediaSource *self)
{
	PyGILState_STATE __py_state;
	PyObject *py_self;
	PyObject *py_method;
	PyObject *py_retval;
	GList *ret;

	__py_state = pyg_gil_state_ensure();
	py_self = pygobject_new((GObject *)self);
	if (!py_self) {
		if (PyErr_Occurred())
			PyErr_Print();
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_method = PyObject_GetAttrString(py_self, "do_impl_get_mime_types");
	if (!py_method) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	py_retval = PyObject_CallObject(py_method, NULL);
	if (!py_retval) {
		if (PyErr_Occurred())
			PyErr_Print();
		Py_DECREF(py_method);
		Py_DECREF(py_self);
		pyg_gil_state_release(__py_state);
		return NULL;
	}

	ret = _helper_unwrap_string_pylist (py_retval, TRUE);

	Py_DECREF(py_retval);
	Py_DECREF(py_method);
	Py_DECREF(py_self);
	pyg_gil_state_release(__py_state);

	return ret;
}
%%
override rb_removable_media_manager_queue_transfer kwargs

typedef struct {
	PyObject *func;
	PyObject *data;
} PyCallbackData;

static void
_rb_removable_media_manager_queue_transfer_func (RhythmDBEntry *entry, const char *dest, GError *error, PyCallbackData *data)
{
	PyObject *args;
	PyObject *result;
	PyObject *py_entry;
	PyGILState_STATE __py_state;

	__py_state = pyg_gil_state_ensure();

	/* XXX no idea what to do with the error here.. */
	py_entry = pyg_boxed_new (RHYTHMDB_TYPE_ENTRY, entry, FALSE, FALSE);
	if (data->data) {
		args = Py_BuildValue ("(OsO)", py_entry, dest, data->data);
	} else {
		args = Py_BuildValue ("(Os)", py_entry, dest);
	}

	result = PyEval_CallObject (data->func, args);
	Py_DECREF (py_entry);
	Py_DECREF (args);
	Py_XDECREF (result);

	Py_DECREF (data->func);
	Py_DECREF (data->data);
	pyg_gil_state_release(__py_state);
}

static PyObject *
_wrap_rb_removable_media_manager_queue_transfer(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "entry", "dest", "mimetypes", "callback", "data", NULL };
	PyObject *py_entry, *py_mimes;
	char *dest = NULL;
	GList *mimes;
	RhythmDBEntry *entry;
	PyCallbackData *data;

	data = g_new0(PyCallbackData, 1);
	if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OsOO|O:RBRemovableMediaManager.queue_transfer", kwlist,
					 &py_entry, &dest, &py_mimes, &data->func, &data->data))
		return NULL;
	if (pyg_boxed_check(py_entry, RHYTHMDB_TYPE_ENTRY)) {
		entry = pyg_boxed_get(py_entry, RhythmDBEntry);
	} else {
		PyErr_SetString(PyExc_TypeError, "entry should be a RhythmDBEntry");
		return NULL;
	}
	if (!PyCallable_Check (data->func)) {
		PyErr_SetString (PyExc_TypeError, "func must be callable");
		return NULL;
	}
   	mimes = _helper_unwrap_string_pylist (py_mimes, FALSE);

	rb_removable_media_manager_queue_transfer(RB_REMOVABLE_MEDIA_MANAGER(self->obj), entry, dest, mimes,
		(RBTransferCompleteCallback)_rb_removable_media_manager_queue_transfer_func, data);

	g_list_free (mimes);
	Py_INCREF(Py_None);
	return Py_None;
}

%%
override rb_streaming_source_get_progress noargs
static PyObject *
_wrap_rb_streaming_source_get_progress(PyGObject *self)
{
    char *progress_text = NULL;
    float progress = 0.0f;
    PyObject *tuple;

    rb_streaming_source_get_progress (RB_STREAMING_SOURCE (self->obj), &progress_text, &progress);
    tuple = Py_BuildValue ("sf", progress_text, progress);
    g_free (progress_text);
    return tuple;
}
%%
override RBSource__proxy_do_impl_get_delete_action
static char *
_wrap_RBSource__proxy_do_impl_get_delete_action(RBSource *self)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_retval;
    PyObject *py_method;
    char *ret = NULL;

    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return NULL;
    }

    py_method = PyObject_GetAttrString(py_self, "do_impl_get_delete_action");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    py_retval = PyObject_CallObject(py_method, NULL);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_method);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return NULL;
    }
    if (py_retval == Py_None) {
        if (PyErr_Occurred())
            PyErr_Print();
        PyErr_SetString(PyExc_TypeError, "retval was None");
    } else if (PyString_Check(py_retval) == FALSE) {
        /* nothing */
    } else {
	ret = g_strdup (PyString_AsString(py_retval));
    }

    Py_DECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);

    return ret;
}

%%
override RBSource__do_impl_get_delete_action
static PyObject *
_wrap_RBSource__do_impl_get_delete_action(PyObject *cls, PyObject *args, PyObject *kwargs)
{
    gpointer klass;
    static char *kwlist[] = { "self", NULL };
    PyGObject *self;
    PyObject *tuple;
    char *key = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:RBSource.impl_get_delete_action", kwlist, &PyRBSource_Type, &self))
	return NULL;

    klass = g_type_class_ref(pyg_type_from_object(cls));
    if (RB_SOURCE_CLASS(klass)->impl_get_delete_action) {
	key = RB_SOURCE_CLASS(klass)->impl_get_delete_action(RB_SOURCE(self->obj));
    } else {
	PyErr_SetString(PyExc_NotImplementedError, "virtual method RBSource.impl_get_delete_action not implemented");
	g_type_class_unref(klass);
	return NULL;
    }
    g_type_class_unref(klass);

    tuple = Py_BuildValue ("(s)", key);
    g_free (key);
    return tuple;
}
%%
override rb_metadata_get kwargs
static PyObject *
_wrap_rb_metadata_get(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "field", NULL };
	PyObject *py_field = NULL;
	RBMetaData *metadata;
	int field;
	GValue value = {0,};
	PyObject *ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:RBMetaData.get", kwlist, &py_field))
		return NULL;
	if (pyg_enum_get_value(RB_TYPE_METADATA_FIELD, py_field, &field))
		return NULL;

	metadata = RB_METADATA (self->obj);
	g_value_init (&value, rb_metadata_get_field_type ((RBMetaDataField)field));
	rb_metadata_get (metadata, (RBMetaDataField)field, &value);
	ret = pyg_value_as_pyobject (&value, TRUE);
	g_value_unset (&value);
	if (ret)
		return ret;
	Py_RETURN_NONE;
}
%%
override rb_metadata_set kwargs
static PyObject *
_wrap_rb_metadata_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "field", "value", NULL };
	PyObject *py_field = NULL;
	PyObject *py_value = NULL;
	int field;
	GValue value = {0,};
	GType field_type;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:RBMetaData.set", kwlist, &py_field, &py_value))
		return NULL;
	if (pyg_enum_get_value(RB_TYPE_METADATA_FIELD, py_field, &field))
		return NULL;

	field_type = rb_metadata_get_field_type ((RBMetaDataField)field);
	g_value_init(&value, field_type);
	if (pyg_value_from_pyobject(&value, py_value) < 0) {
		char *s;

		s = g_strdup_printf ("could not convert argument from type '%s' (%d) to correct type '%s'",
					 g_type_name (pyg_type_from_object (py_value)),
					 (int)pyg_type_from_object (py_value),
					 g_type_name (field_type));
		PyErr_SetString(PyExc_TypeError, s);
		g_free (s);
		return NULL;
	}
	rb_metadata_set (RB_METADATA (self->obj), (RBMetaDataField)field, &value);
	g_value_unset (&value);
	Py_RETURN_NONE;
}
%%
override RBSource__proxy_do_impl_search
static void
_wrap_RBSource__proxy_do_impl_search(RBSource *self, RBSourceSearch*search, const char*cur_text, const char*new_text)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_search = NULL;
    PyObject *py_cur_text;
    PyObject *py_new_text;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;

    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }

    if (search)
        py_search = pygobject_new((GObject *) search);
    else {
        Py_INCREF(Py_None);
        py_search = Py_None;
    }

    if(cur_text)
        py_cur_text = PyString_FromString(cur_text);
    else {
        Py_INCREF(Py_None);
        py_cur_text = Py_None;
    }
    if (!py_cur_text) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_search);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }

    if(new_text)
        py_new_text = PyString_FromString(new_text);
    else {
        Py_INCREF(Py_None);
        py_new_text = Py_None;
    }
    if (!py_new_text) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_cur_text);
        Py_DECREF(py_search);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }

    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_search);
    PyTuple_SET_ITEM(py_args, 1, py_cur_text);
    PyTuple_SET_ITEM(py_args, 2, py_new_text);

    py_method = PyObject_GetAttrString(py_self, "do_impl_search");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "virtual method should return None");
        PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }


    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
%%
override RBSource__proxy_do_impl_add_uri
static gboolean
_wrap_RBSource__proxy_do_impl_add_uri(RBSource *self, const char*uri, const char*title, const char*genre, RBSourceAddCallback callback, gpointer data, GDestroyNotify destroy_data)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_uri = NULL;
    PyObject *py_title;
    PyObject *py_genre;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;
    
    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return;
    }
    if (uri)
        py_uri = PyString_FromString(uri);
    if (!py_uri) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    if (title)
        py_title = PyString_FromString(title);
    else {
        Py_INCREF(Py_None);
        py_title = Py_None;
    }
    if (genre)
        py_genre = PyString_FromString(genre);
    else {
        Py_INCREF(Py_None);
        py_genre = Py_None;
    }
    
    py_args = PyTuple_New(3);
    PyTuple_SET_ITEM(py_args, 0, py_uri);
    PyTuple_SET_ITEM(py_args, 1, py_title);
    PyTuple_SET_ITEM(py_args, 2, py_genre);
    
    py_method = PyObject_GetAttrString(py_self, "do_impl_add_uri");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (callback) {
	callback (self, uri, data);
	if (destroy_data) {
	    destroy_data (data);
	}
    }

    if (PyErr_Occurred())
	PyErr_Print();
    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);
}
